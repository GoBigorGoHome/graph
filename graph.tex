\documentclass{ctexbook}
\usepackage{amsmath}
\usepackage{amsthm} % proof
\usepackage{amssymb} % \mathbb
% \usepackage{amstext} % \text
\newtheorem{theorem}{定理}
\newtheorem{lemma}{引理}
\usepackage{listings}
\lstset{language=C++, basicstyle=\ttfamily, frame=lines}
\newcommand{\idx}{\mathrm{idx}}

\begin{document}
    \chapter{图论高级算法}
    \section{最大流}
    最大流算法分成两大类：增广路（augmengting path）算法与预流推进（preflow-push）算法。
    这一节介绍的三个算法，都属于增广路算法。
    下面给出几个术语和定义。
    \subsubsection*{流网络}\label{notations}
    最大流问题（maximum flow problem）是网络流问题（network flow problem）的一种。网络流问题的研究对象是流网络（flow network），在某些文献中流网络也称作网络流图（network flow graph）。流网络$G=(V,E,c,s,t)$是一个有向图，$V$、$E$是其点集与边集，点和边的数目分别记作$n$、$m$。$c\colon V\times V\to \mathbb{N}$是边的容量函数，每条边$(u,v)\in E$都有一容量$c(u,v)\in \mathbb{N}$，若$(u,v)\notin E$则$c(u,v) = 0$。$s$和$t$是流网络中的两个特殊点，分别称作源点和汇点。为简便计，流网络简称「网络」或「图」，简记作$G=(V,E)$。

    自环在网络中无意义，我们规定图$G$中不含自环。%允许网络中有重边。
    下文在论述、证明关于网络流的原理、性质或定理时，为了表示上的方便，我们对流网络做出两条限定：
    \begin{enumerate}
        \item 图中不存在重边；\label{Restrict:1}
        \item 图中不存在反向边，即若$(u,v)\in E$，则$(v,u)\notin E$。\label{Restrict:2}
    \end{enumerate}
    这两条限定都不妨碍一般性。我们可以通过将容量相加把重边合为一条边，反向边可以通过新增一个节点来消除。请读者注意，上文所谓「表示上的方便」是指一条边可以通过两个端点唯一确定。下文我们要介绍的算法和代码可以处理含有重边或反向边的图，这两条限定都不是根本性的，仅仅是为了方便表述而已。

    \subsubsection*{流}
    流是满足下述两个性质的实值函数$f\colon V\times V\to\mathbb{R}$：
    \begin{description}
        \item[容量限制：]对任意$u,v \in V$，有 $0\le f(u,v)\le c(u,v)$。
        \item[流守恒：]对任意$u\in V-\{s,t\}$，有$\sum\limits_{v\in V}f(v,u)= \sum\limits_{v\in V}f(u,v)$
    \end{description}
    $f(u,v)$即边$(u,v)$上的流量，若$(u,v)\notin E$，$f(u,v) = 0$。
    从源点$s$到汇点$t$的总流量称作流$f$的值，记作$|f|$，不难得出
    $$|f| = \sum_{v\in V}f(s,v) - \sum_{v\in V}f(v,s)\text{，}$$
    最大流问题即在给定的网络$G$中求一个值最大的流。

    \subsection{增广路方法}
    增广路方法是求解最大流问题的一种方法。本章要介绍的三个最大流算法都是基于增广路方法的。增广路算法涉及三个重要概念：残量网络，增广路，割。
    \subsubsection*{残量网络}
    给定流网络$G=(V,E)$和$G$上的一个流$f$，残量网络$G_f=(V,E_f,c_f, s, t)$是由$G$和$f$所导出的一个网络，简记作$G_f=(V,E_f)$。首先定义残余容量$c_f$：
    \[
    c_f(u,v) =
    \begin{cases}
        c(u,v) - f(u,v) & \text{若$(u,v)\in E$,}\\
        f(v,u) & \text{若$(v,u)\in E$,} \\
        0 & \text{其他情况.}
    \end{cases}
    \]
    这里需要指出我们提出限制\ref{Restrict:2} 的用意。$(u,v)\in E$和$(v,u)\in E$同时成立会给$c_f$的定义带来形式上的不便。残量网络$G_f$的边集$E_f$定义为
    \[
    E_f = \{(u,v)\in V\times V\colon c_f(u,v)>0\}.
    \]
    除了可能含有反向边，残量网络也符合流网络的定义；而我们已经指出「不含反向边」并非根本性的要求，借助残余容量$c_f$，我们可以类似地定义残量网络上的流，称作\emph{残量流}。

    我们考虑残量流的原因在于，借助残量网络$G_f$上的残量流$f'$，可以将网络$G$上的流$f$修改成一个值更大的流$f\uparrow f'$；即用$f'$ 增广 $f$，这正是「增广」二字含义所在。增广方法为：
    \[
    (f\uparrow f')(u,v) =\begin{cases}
    f(u,v) + f'(u,v) - f'(v,u) & \text{若$(u,v)\in E$,} \\
    0 & \text{其他情况.}
\end{cases}
    \]
    不难证明$|f\uparrow f'| = |f| + |f'|$。
    \subsubsection{增广路}
    增广路是残量网络$G_f$上从$s$到$t$的一条简单路径。有了增广路$p$，很容易得到一个残量流$f_p$。
    \[
    f_p(u,v) =\begin{cases}
    c_f(p) & \text{若边$(u,v)$在路径 $p$ 上,}\\
    0 & \text{其他情况.}
\end{cases}
    \]
    其中$c_f(p) = \min\{c_f(u,v)\colon (u,v)\text{ 在路径 }p\text{ 上} \}$，$c_f(p)$称作路径$p$的残余容量。易见，$|f_p| = c_f(p) > 0$。

    增广路方法即，从图$G$上的某个初始流$f$（比如零流）开始，在$G_f$找一条增广路$p$；沿着$p$增广，更新$f$和$G_f$；如此循环，直到$G_f$上找不到增广路。此时$f$便是$G$上的一个最大流。下面要介绍的最大流最小割定理证明了增广路方法的正确性。
    \subsubsection*{流网络的割}
    为了给出最大流最小割定理，我们先介绍割的概念。
    将流网络$G=(V,E)$的点集$V$划分成两个子集$S$和$T=V-S$使得$s\in S$且$t\in T$，$(S,T)$称作$G$的一个割。令$f$为$G$上的一个流，割$(S,T)$之间的\emph{净流}$f(S,T)$定义为
    \[
    f(S,T) = \sum_{u\in S}\sum_{v\in T}f(u,v) - \sum_{u\in S}\sum_{v\in T}f(v,u)
    \]
    不难证明，对$G$的任意一个割$(S,T)$都有$f(S,T) = |f|$。
    割$(S,T)$的容量$c(S,T)$定义为
    \[
    c(S,T) = \sum_{u\in S}\sum_{v\in T}c(u,v)
    \]
    网络的最小割即所有割之中容量最小者。显然，对于$G$上的任意一个流$f$和$G$的任意一个割$(S,T)$都有 $f \le c(S,T)$。
    \begin{theorem}[最大流最小割定理]
        若$f$是流网络$G=(V,E,c,s,t)$上的一个流，则下列三个命题等价：
        \begin{enumerate}
            \item $f$是$G$上的一个最大流。
            \item 残量网络 $G_f$ 上无增广路。
            \item 存在某个割$(S,T)$满足$|f| = c(S,T)$。
        \end{enumerate}
    \end{theorem}
    \begin{proof}
        (1)$\Rightarrow$(2)：显然。

        (2)$\Rightarrow$(3)：假设 $G_f$中无增广路，即$G_f$上不存在从$s$到$t$的路径。令$S=\{v\in V\colon G_f\text{ 上有从}\ s\text{ 到}\ v\text{ 的路径}\}$，$T=V-S$，易见$t\notin S$，则$(S,T)$是一个割。考虑点对$u\in S$和$v\in T$。若$(u,v)\in E$，则必有$f(u,v)=c(u,v)$；因为若不然则有$(u,v)\in E_f$，即$v\in S$。若$(v,u)\in E$，则必有$f(v,u)=0$；因为若不然则有$c_f(u,v) = f(v,u) > 0$，即$(u,v)\in E_f$，仍有$v \in S$。若$(u,v)\notin E$且$(v,u)\notin E$，则$f(u,v)=f(v,u)=0$。因此我们有
        \begin{align*}
            f(S,T) &= \sum_{u\in S}\sum_{v\in T}f(u,v) - \sum_{v\in T}\sum_{u\in S}f(v,u)\\
            &= \sum_{u\in S}\sum_{v\in T}c(u,v) - \sum_{v\in T}\sum_{u\in S}0\\
            &= c(S, T)
        \end{align*}
        所以 $|f| = f(S,T) = c(S, T)$。

        (3)$\Rightarrow$(1)：由于对任意割$(S,T)$都有$|f|\le c(S,T)$，$|f|=c(S,T)$蕴含着$f$是一个最大流。
    \end{proof}

    不难看出，高效地实现增广路方法应从两个方面考虑：
    \begin{enumerate}
        \item 如何快速地在残量网络$G_f$上找一条增广路。\label{Approach:1}
        \item 如何减少增广的次数。\label{Approach:2}
    \end{enumerate}
    我们已经知道，通过深度优先搜索（DFS）或宽度优先搜索（BFS）可在线性间内找到一条增广路。
    在下一小节中我们将证明，如果每次都沿着\emph{最短增广路}(shortest augmenting path，SAP)增广，那么增广次数是$O(VE)$的。沿着最短增广路增广的算法统称为最短增广路算法。下面三个小节中要介绍的算法都属于最短增广路算法。
    \subsection{Edmonds-Karp算法}
    Edmonds-Karp是SAP算法的朴素实现。代码如下：
    \lstinputlisting{code/ek.cpp}
    说明：
    \begin{enumerate}
        \item 用链式前向星存图。
        \item 对任意边$e \in E$，$e$在边数组中的下标$\idx(e)$为偶数，$e$的反向边$e'$的下标$\idx(e') = \idx(e) + 1$。
    \end{enumerate}

    下面我们来分析Edmonds-Karp算法的时间复杂度。用$\delta_f(u,v)$表示残量网络$G_f$上从$u$到$v$的距离，$G_f$中边的长度都是$1$。
    \begin{lemma}\label{Lemma:1}
        用Edmonds-Karp算法求流网络$G=(V,E,c,s,t)$的最大流的过程中，对任意节点$v\in V-\{s,t\}$，残量网络$G_f$上从源点$s$到$v$的距离$\delta_f(s,v)$在每次增广之后不会减小。
    \end{lemma}
    \begin{proof}
        假设此命题不成立。
        设$v$是$V-\{s,t\}$中一点；令$f$为「$s$到$v$的距离减小」首次出现之前的流，令$f'$为$f$增广之后的流。再令$v$为满足$\delta_f(s,v)>\delta_{f'}(s,v)$的点中$\delta_{f'}(s,v)$最小的一个点。令$p = s \leadsto u\to v$为$G_{f'}$中从$s$到$v$的一条最短路，因而有$(u,v)\in E_{f'}$且
        \begin{equation}
            \delta_{f'}(s,u) = \delta_{f'}(s,v) - 1 . \label{Eq:1}
        \end{equation}
        又由于$v$是满足$\delta_f(s,v)>\delta_{f'}(s,v)$的点中$\delta_{f'}(s,v)$最小者，我们有
        \begin{equation}
            \delta_{f'}(s,u)\ge\delta_f(s,u). \label{Ineq:1}
        \end{equation}
        由上两式我们能推导出$(u,v)\notin E_f$。若不然，即$(u,v)\in E_f$，则有
        \begin{align*}
            \delta_f(s,v) &\le \delta_f(s,u)+1 &\text{依据三角形不等式} \\
            &\le \delta_{f'}(s,u) + 1 &\text{依据 \eqref{Ineq:1} 式}\\
            &= \delta_{f'}(s,v) &\text{依据 \eqref{Eq:1} 式}
        \end{align*}
        这与$\delta_{f'}(s,v) < \delta_f(s,v)$矛盾。

        由$(u,v)\notin E_f$且$(u,v)\in E_{f'}$，我们可以推知在$G_f$上所选的那条增广路一定经过了边$(v,u)$。因此有
        \begin{align*}
            \delta_f(s,v) &= \delta_f(s,u) - 1  \\
            &\le\delta_{f'}(s,u) - 1 & \text{（根据 \eqref{Ineq:1} 式）}\\
            &=\delta_{f'}(s,v) - 2 & \text{（根据 \eqref{Eq:1} 式）}
        \end{align*}
        这与我们的假设$\delta_{f'}(s,v) < \delta_f(s,v)$相矛盾。
    \end{proof}

    \begin{theorem}
        在流网络$G=(V,E,c,s,t)$上，Edmonds-Karp算法的总增广次数为$O(VE)$。
    \end{theorem}
    \begin{proof}
        设$p$为残量网络$G_f$中的一条增广路，$(u,v)$为$p$上的一条边。若有$c_f(p) = c_f(u,v)$，则称$(u,v)$为$p$的瓶颈边。不难看出，(i)沿着$p$增广后，$p$上的瓶颈边都消失了；(ii) $p$上至少有一条瓶颈边。下面我们证明：一条边在$G_f$上成为瓶颈边的次数至多为$|V|/2$。

        令$(u,v)$为残量网络$G_f$中的一条边。当$(u,v)$首次成为瓶颈边时，我们有
        \[
        \delta_f(s,v) = \delta_f(s,u) + 1 .
        \]
        增广之后，边$(u,v)$将从残余网络中消失。下一次$(u,v)$出现在残量网络中，必然是在某次$(v,u)$出现在增广路上之后。设上述「$(v,u)$成为增广路上的边」这一情况发生时$G$上的流为$f'$，则有
        \[
        \delta_{f'}(s,u) = \delta_{f'}(s,v) + 1.
        \]
        根据引理 \ref{Lemma:1} 有 $\delta_f(s,v)\le\delta_{f'}(s,v)$，因而有
        \begin{align*}
            \delta_{f'}(s,u) &= \delta_{f'}(s,v) + 1 \\
            &\ge \delta_f(s,v) + 1 \\
            &= \delta_f(s,u) + 2 .
        \end{align*}

        所以从某次$(u,v)$成为瓶颈边到$(u,v)$下一次成为瓶颈边，从源点$s$到$u$的距离至少增加$2$。初始时$s$到$u$的距离至少为$0$。从$s$到$u$的最短路上的中间节点必定不包含$s$，$u$ 或者$t$（边$(u,v)$在最短路上蕴含着$u\ne t$）。因此，只要$s\leadsto u$的路径存在，$s$到$u$的距离至多为$|V|-2$。所以在$(u,v)$首次成为瓶颈边之后，它最多还能在成为$(|V|-2)/2=|V|/2-1$次瓶颈边，共计$|V|/2$次。又由于在残量网络上有$O(E)$对点之间可能有边相连，在Edmonds-Karp算法运行过程中瓶颈边的总数是$O(VE)$的。
    \end{proof}

    我们可以通过BFS在$O(E)$的时间内在残量网络上找到一条$s\leadsto t$最短路，因此Edmonds-Karp算法的时间复杂度为$O(VE^2)$。严格说来，BFS的时间复杂度应为$O(V+E)$；但是在流网络$G$中一个点应至少有一条边与其相连（孤立的点是无意义的）所以我们有$|V|\le2|E|$。
    \subsection{Dinic算法}
    Dinic算法是对Edmonds-Karp算法的改进，它的时间复杂度是$O(n^2m)$\footnote{在\S\ref{notations}中，我们约定了$n=|V|$，$m=|E|$。}。下面给出Dinic算法的的代码，其中图的表示部分与Edmonds-Karp算法的代码相同，故略去。
    \lstinputlisting{code/dinic.cpp}

    先介绍Dinic算法用到的两个概念：分层图（level graph）和阻塞流（blocking flow）。
    \subsubsection*{分层图}
    设$f$是网络$G$上的一个流，以$s$为起点对$G_f$做一次BFS，将$s$到$u$的距离记作$\mathrm{level}(u)$。$G_f$的分层图$G'_f$是由$G_f$所导出的一个流网络。$G'_f$定义为
    \[
    G'_f =(V, E'_f, c'_f, s, t)
    \]
    其中
    \begin{align*}
        E'_f &= \{(u,v)\in E_f\colon \mathrm{level}(v) = \mathrm{level}(u)+1\} \\
        c'_f(u,v) &=\begin{cases}
        c_f(u,v), & (u,v)\in E'_f;\\
        0, & (u,v)\notin E'_f.\end{cases}
    \end{align*}
    简记作$G'_f =(V, E'_f)$。
    \subsubsection{阻塞流}
    首先要指出的是，由$G_f$所导出的分层图$G'_f$完全符合\S\ref{notations} 中流网络的定义（$G'_f$与$G_f$不同的地方在于$G'_f$中一定不含有反向边）。此外，不难看出$G'_f$中的任意一条$s\leadsto t$路径都是$s\leadsto t$最短路。

    设$f$是网络$G=(V,E)$上的一个流，$(u,v)\in E$是$G$上的一条边；若$f(u,v) = c(u,v)$则称边$(u,v)$是\emph{饱和}的。又设$f'$是层次图$G'_f$上的一个流，若$G'_f$中的任意一条$s\leadsto t$路径上都至少有一条饱和边，则称$f'$是$G'_f$上的一个阻塞流。注意，$G'_f$上阻塞流未必是$G'_f$上的最大流；下面我们给出一个例子：
    \begin{figure}
        \centering
        \includegraphics[scale=0.5]{figures/blocking-flow.png}
        \caption{阻塞流非最大流的一个例子。黑色边是非饱和边，灰色边是饱和边}
        \label{Fig:blocking-flow}
    \end{figure}

    下面考虑如何构造阻塞流。前面已经提到，层次图$G'_f$是一个流网络；所以一个自然的想法便是在$G'_f$上不断地DFS寻找增广路\footnote{准确地说应该是「在$G'_f$的残量网络上找增广路」，但我们在$G'_f$要求的是一个阻塞流而不是最大流，无须考虑反向边。}并沿着找到的增广路增广。每次增广至少会使一条边饱和，所以至多增广$m$次；可以在$O(M)$的时间内在分层图上找到一条$s\leadsto t$增广路。，所以构造阻塞流的复杂度是不超过$O(m^2)$。下面我们介绍一种称作「当前边」的优化\footnote{有的资料将此优化称作当前弧优化}，可使构造阻塞流的复杂度达到$O(nm)$。对层次图中的每个节点$u$维护一个指针 \texttt{current\_edge[u]}
    %（由于$G'_f$是$G_f$的子图，将$G'_f$上$s\leadsto t$路径称作增广路是不失严格性的）

    \subsection{ISAP算法}
    \subsection{网络流的建图}
    \section{费用流}
    \section{二分图}
    \subsection{最大流和二分图}
    \subsection{匈牙利算法}
    \subsection{二分图模型应用}
    \section{图的连通}
    \subsection{强连通-Tarjan算法}
    \subsection{双连通}
    \subsection{2-SAT问题}
\end{document}
